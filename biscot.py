#!/usr/bin/env python3

from biscot_libs import Alignment
from biscot_libs import Anchor
from biscot_libs import Map
from biscot_libs import Misc

from Bio.Seq import Seq
from Bio import SeqIO
from collections import defaultdict

import argparse
import copy
import logging
import math
import os
import re
import shutil
import subprocess
import sys


def main() :
    Misc.print("")

    parser = argparse.ArgumentParser(prog="biscot.py", 
        description="Reorganizes scaffolds generated by the Bionano Access to remove small gaps that are unnecessary",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False)

    mandatory_args = parser.add_argument_group("Mandatory arguments")
    mandatory_args.add_argument("--cmap-ref",
        action="store", 
        dest="cmap_ref_path", 
        help="Path to the reference CMAP file (example : '...NGS_contigs_HYBRID_Export_r.cmap')",
        default="",
        required=True)
    mandatory_args.add_argument("--cmap-1",
        action="store", 
        dest="cmap_1_path", 
        help="Path to a query CMAP file (example : 'E_CTTAAG_Q_NGScontigs_A_HYBRID_q.cmap')",
        default="",
        required=True)
    mandatory_args.add_argument("--xmap",
        action="store", 
        dest="xmap_path", 
        help="Path to a XMAP file",
        default="",
        required=True)
    mandatory_args.add_argument("--key",
        action="store", 
        dest="key_path", 
        help="Path to the Bionano 'key' file giving the correspondance between maps and contigs",
        default="",
        required=True)
    mandatory_args.add_argument("--contigs",
        action="store", 
        dest="contigs_path", 
        help="Path to the contigs file that was scaffolded by the Bionano Access",
        default="",
        required=True)

    secondary_map_args = parser.add_argument_group("Secondary map argument")
    secondary_map_args.add_argument("--cmap-2",
        action="store", 
        dest="cmap_2_path", 
        help="Path to a query cmap (example : 'E_GCTCTTC_Q_NGScontigs_A_HYBRID_q.cmap')",
        default=None,
        required=False)

    optional_args = parser.add_argument_group("Optional arguments")
    optional_args.add_argument("--prefix", "-p",
        action="store", 
        dest="prefix", 
        help="Prefix of the output agp and fasta files to be created (default : %(default)s)",
        default="scaffolds",
        required=False)
    optional_args.add_argument("--output", "-o",
        action="store", 
        dest="output_directory", 
        help="Name of the output directory (default : %(default)s)",
        default="biscot",
        required=False)
    optional_args.add_argument("--debug", 
        action="store_true", 
        dest="debug", 
        help="Activates debug level logs (default : %(default)s)",
        default=False,
        required=False)
    optional_args.add_argument("--help", "-h", 
        action="help", 
        help="show this help message and exit")

    args = parser.parse_args()
    args.cmap_ref_path = os.path.abspath(args.cmap_ref_path)
    args.cmap_1_path = os.path.abspath(args.cmap_1_path)
    if args.cmap_2_path : args.cmap_2_path = os.path.abspath(args.cmap_2_path)
    args.xmap_path = os.path.abspath(args.xmap_path)
    args.contigs_path = os.path.abspath(args.contigs_path)
    args.key_path = os.path.abspath(args.key_path)

    try :
        os.mkdir(args.output_directory)
    except :
        pass
    os.chdir(args.output_directory)

    with open("biscot.log", "w") :
        pass
    Misc.setup_logging(args.debug)
    logging.info("Command used : %s" % (" ".join(sys.argv)))

    logging.info("Starting phase 1")
    try :
        os.mkdir("Phase_1")
    except :
        logging.debug("Phase_1 directory already created")
    os.chdir("Phase_1")


    logging.info("Loading assembly")
    dict_sequences = {}
    with open(args.contigs_path) as assembly :
            for record in SeqIO.parse(assembly, "fasta") :
                    dict_sequences[record.description] = str(record.seq)


    logging.info("Loading key file")
    maps_to_contigs = {}
    with open(args.key_path) as key_file :
        # Remove header lines
        line = key_file.readline()
        while line.split("\t")[0] != "CompntId" :
            line = key_file.readline()

        for line in key_file :
            map_id, contig_name, size = line.strip().split("\t")
            maps_to_contigs[int(map_id)] = Map.Map(int(map_id), contig_name, size)
            maps_to_contigs[int(map_id)].update_map(contig_name, dict_sequences)
    

    logging.info("Retrieving contig maps labels")
    cmap = open(args.cmap_1_path)
    for line in cmap :
        if not line.startswith("#") :
            line = line.strip().split("\t")
            maps_to_contigs[int(line[0])].add_label(line, 1)
    cmap.close()

    if args.cmap_2_path :
        cmap = open(args.cmap_2_path)
        for line in cmap :
            if not line.startswith("#") :
                line = line.strip().split("\t")
                maps_to_contigs[int(line[0])].add_label(line, 2)
        cmap.close()


    logging.info("Retrieving anchor labels")
    anchor_dict = {}
    with open(args.cmap_ref_path) as cmap :
        for line in cmap :
            if not line.startswith("#") :
                line = line.strip().split("\t")

                for i in range(0, len(line)) :
                    line[i] = line[i].replace(" ", "")

                # DLE labels
                if line[4] == "1" :
                    try :
                        anchor_dict[int(line[0])].add_DLE_label(line)
                    except :
                        anchor_dict[int(line[0])] = Anchor.Anchor(int(line[0]))
                        anchor_dict[int(line[0])].add_DLE_label(line)

                # BspQI labels
                elif line[4] == "2" :
                    try :
                        anchor_dict[int(line[0])].add_BspQI_label(line)
                    except :
                        anchor_dict[int(line[0])] = Anchor.Anchor(int(line[0]))
                        anchor_dict[int(line[0])].add_BspQI_label(line)


    logging.info("Parsing xmap file")
    with open(args.xmap_path) as xmap :
        for line in xmap :
            if not line.startswith("#") :
                aln = Alignment.Alignment(line)
                anchor_dict[aln.anchor_id].add_alignment(aln)    


    logging.info("Removing badly mapped contig maps")
    aln_to_remove = defaultdict(list)
    for anchor in anchor_dict :
        for i, aln in enumerate(anchor_dict[anchor]) :
            map_id = aln.map_id
            number_mapped_anchor_labels = len(aln.label_mappings)
            number_total_labels_map = len(maps_to_contigs[map_id].labels)
            if number_mapped_anchor_labels / number_total_labels_map < 0.4 :
                logging.debug("Anchor %s : Map %s is badly mapped (%.2f %% labels mapping)" % (anchor, map_id, number_mapped_anchor_labels / number_total_labels_map * 100))
                aln_to_remove[anchor].append(i)

    for anchor in aln_to_remove :
        for pos in aln_to_remove[anchor] :
            logging.debug("Removing alignment of map %s on anchor %s" % (anchor_dict[anchor].alignments[pos].map_id, anchor))
        anchor_dict[anchor].alignments = [i for j, i in enumerate(anchor_dict[anchor].alignments) if j not in aln_to_remove[anchor]]

    logging.info("Looking for maps contained into others")
    new_map_id = max(maps_to_contigs.keys()) + 1
    aln_to_remove = defaultdict(list)
    for anchor in anchor_dict :
        for i, aln_1 in enumerate(anchor_dict[anchor].alignments) :
            for j, aln_2 in enumerate(anchor_dict[anchor].alignments) :
                if i != j :

                    """
                    Map 1 alignment positions on anchor : from S1 to E1 in '+' orientation
                    Map 2 alignment positions on anchor : from S2 to E2 in '+' orientation
                    Let's imagine that map 2 is contained into map 1, that means :
                    S2 > S1 and E2 < E1
                    The purpose of this block is to break the alignment of map 1 into two smaller alignments to be able to find a path later in the code. After this block, we will have these alignments :
                    Map 1 from S1 to S2
                    Map 2 from S2 to E2
                    Map 1 from E2 to E1
                    We break the alignment at the last label before the overlap

                    If the map is contained into an other one but we can't find a proper place to include it, the alignment is removed
                    """

                    # Map 1 is contained in map 2
                    if aln_1.anchor_end - maps_to_contigs[aln_1.map_id].size > aln_2.anchor_start and aln_1.anchor_start + maps_to_contigs[aln_1.map_id].size < aln_2.anchor_end :
                        logging.debug("Anchor %s : Map %s contained in map %s" % (anchor, aln_1.map_id, aln_2.map_id))

                        # If map 1 mapped better than map 2, we conserve alignment
                        # Otherwise, we delete it
                        nb_labels_mapped_aln_1 = len(aln_1.get_anchor_labels_in_interval(aln_1.anchor_start, aln_1.anchor_end, anchor_dict[anchor]))
                        nb_labels_mapped_aln_2 = len(aln_2.get_anchor_labels_in_interval(aln_1.anchor_start, aln_1.anchor_end, anchor_dict[anchor]))
                        if nb_labels_mapped_aln_1 < nb_labels_mapped_aln_2 : 
                            aln_to_remove[anchor].append(i)
                            logging.debug("Anchor %s : Map %s is badly mapped, alignment will be removed" % (anchor, aln_1.map_id))
                            continue 

                        logging.debug("Anchor %s : Map %s mapped better than map %s, splitting alignment" % (anchor, aln_1.map_id, aln_2.map_id))

                        # If maps don't share labels, we can't split the alignment
                        intersection = Alignment.find_shared_labels(anchor_dict[anchor], aln_1.map_id, aln_2.map_id)
                        if not intersection :
                            logging.debug("No labels shared, can't split the alignment")
                            continue

                        aln_copy = Alignment.Alignment(aln_2.line)
                        if aln_1.orientation == "+" :
                            aln_copy.set_anchor_start(aln_1.anchor_end + (maps_to_contigs[aln_1.map_id].size - aln_1.map_end))
                        else :
                            aln_copy.set_anchor_start(aln_1.anchor_end + (maps_to_contigs[aln_1.map_id].size - aln_1.map_start))

                        removed_anchor_labels = aln_copy.update_mappings(anchor_dict[anchor])
                        #first_label = anchor_dict[anchor].find_label_on_contig_map(aln_2.map_id, removed_anchor_labels[0])
                        first_label = removed_anchor_labels[0][1]
                        #last_label = anchor_dict[anchor].find_label_on_contig_map(aln_2.map_id, removed_anchor_labels[1])
                        last_label = removed_anchor_labels[1][1]

                        if aln_2.orientation == "+" :
                            aln_copy.set_map_start(maps_to_contigs[aln_2.map_id].get_label_position_on_map(last_label))
                            anchor_dict[anchor].alignments[j].set_map_end(maps_to_contigs[aln_1.map_id].get_label_position_on_map(first_label))
                            maps_to_contigs[aln_2.map_id].end = maps_to_contigs[aln_2.map_id].start + aln_copy.map_start - 1
                        elif aln_2.orientation == "-" :
                            aln_copy.set_map_start(maps_to_contigs[aln_2.map_id].get_label_position_on_map(last_label))
                            anchor_dict[anchor].alignments[j].set_map_end(maps_to_contigs[aln_2.map_id].get_label_position_on_map(first_label))
                            maps_to_contigs[aln_2.map_id].end = maps_to_contigs[aln_2.map_id].start + aln_copy.map_end + 1

                        if aln_1.orientation == "+" :
                            anchor_dict[anchor].alignments[j].set_anchor_end(aln_1.anchor_start - aln_1.map_start)
                        else :
                            anchor_dict[anchor].alignments[j].set_anchor_end(aln_1.anchor_start - (maps_to_contigs[aln_1.map_id].size - aln_1.map_start))
                        anchor_dict[anchor].alignments[j].update_mappings(anchor_dict[anchor])

                        new_map = Map.Map(new_map_id, maps_to_contigs[aln_copy.map_id].base_contig_name, maps_to_contigs[aln_copy.map_id].size)
                        contig_name = maps_to_contigs[aln_copy.map_id].base_contig_name + "_subseq_" + str(maps_to_contigs[aln_2.map_id].start + min(aln_copy.map_start, aln_copy.map_end)) + ":" + str(maps_to_contigs[aln_2.map_id].start + max(aln_copy.map_end, aln_copy.map_start))
                        new_map.update_map(contig_name, dict_sequences)
                        new_map.labels = maps_to_contigs[aln_copy.map_id].labels
                        maps_to_contigs[new_map_id] = new_map
                        aln_copy.set_map_id(new_map_id)

                        new_map_id += 1

                        anchor_dict[anchor].add_alignment(aln_copy)

                    # Map 2 is contained in map 1
                    elif aln_2.anchor_end - maps_to_contigs[aln_2.map_id].size > aln_1.anchor_start and aln_2.anchor_start + maps_to_contigs[aln_2.map_id].size < aln_1.anchor_end :
                        logging.debug("Anchor %s : Map %s contained in map %s" % (anchor, aln_2.map_id, aln_1.map_id))

                        # If map 2 mapped better than map 1, we conserve alignment
                        # Otherwise, we delete it
                        nb_labels_mapped_aln_1 = len(aln_1.get_anchor_labels_in_interval(aln_2.anchor_start, aln_2.anchor_end, anchor_dict[anchor]))
                        nb_labels_mapped_aln_2 = len(aln_2.get_anchor_labels_in_interval(aln_2.anchor_start, aln_2.anchor_end, anchor_dict[anchor]))
                        if nb_labels_mapped_aln_2 < nb_labels_mapped_aln_1 :
                            aln_to_remove[anchor].append(j)
                            logging.debug("Anchor %s : Map %s is badly mapped, alignment will be removed" % (anchor, aln_2.map_id))
                            continue

                        logging.debug("Anchor %s : Map %s mapped better than map %s, splitting alignment" % (anchor, aln_2.map_id, aln_1.map_id))

                        # If maps don't share labels, we can't split the alignment
                        intersection = Alignment.find_shared_labels(anchor_dict[anchor], aln_1.map_id, aln_2.map_id)
                        if not intersection :
                            logging.debug("No labels shared, can't split the alignment")
                            continue


                        aln_copy = Alignment.Alignment(aln_1.line)
                        if aln_2.orientation == "-" :
                            aln_copy.set_anchor_start(aln_2.anchor_end + (maps_to_contigs[aln_2.map_id].size - aln_2.map_start))
                        else :
                            aln_copy.set_anchor_start(aln_2.anchor_end + (maps_to_contigs[aln_2.map_id].size - aln_2.map_end))

                        removed_anchor_labels = aln_copy.update_mappings(anchor_dict[anchor])
                        #first_label = anchor_dict[anchor].find_label_on_contig_map(aln_1.map_id, removed_anchor_labels[0])
                        first_label = removed_anchor_labels[0][1]
                        #last_label = anchor_dict[anchor].find_label_on_contig_map(aln_1.map_id, removed_anchor_labels[1])
                        last_label = removed_anchor_labels[1][1]

                        if aln_1.orientation == "+" :
                            aln_copy.set_map_start(maps_to_contigs[aln_1.map_id].get_label_position_on_map(last_label))
                            anchor_dict[anchor].alignments[i].set_map_end(maps_to_contigs[aln_1.map_id].get_label_position_on_map(first_label))
                            maps_to_contigs[aln_1.map_id].end = maps_to_contigs[aln_1.map_id].start + aln_copy.map_start - 1
                        elif aln_1.orientation == "-" :
                            aln_copy.set_map_start(maps_to_contigs[aln_1.map_id].get_label_position_on_map(last_label))
                            anchor_dict[anchor].alignments[i].set_map_end(maps_to_contigs[aln_1.map_id].get_label_position_on_map(first_label))
                            maps_to_contigs[aln_1.map_id].end = maps_to_contigs[aln_1.map_id].start + aln_copy.map_end + 1

                        if aln_1.orientation == "+" :
                            anchor_dict[anchor].alignments[i].set_anchor_end(aln_2.anchor_start - aln_2.map_start)
                        else :
                            anchor_dict[anchor].alignments[i].set_anchor_end(aln_2.anchor_start - (maps_to_contigs[aln_2.map_id].size - aln_2.map_start))
                        anchor_dict[anchor].alignments[i].update_mappings(anchor_dict[anchor])

                        new_map = Map.Map(new_map_id, maps_to_contigs[aln_copy.map_id].base_contig_name, maps_to_contigs[aln_copy.map_id].size)
                        contig_name = maps_to_contigs[aln_copy.map_id].base_contig_name + "_subseq_" + str(maps_to_contigs[aln_1.map_id].start + min(aln_copy.map_start, aln_copy.map_end)) + ":" + str(maps_to_contigs[aln_1.map_id].start + max(aln_copy.map_end, aln_copy.map_start))
                        new_map.update_map(contig_name, dict_sequences)
                        new_map.labels = maps_to_contigs[aln_copy.map_id].labels
                        maps_to_contigs[new_map_id] = new_map
                        aln_copy.set_map_id(new_map_id)

                        new_map_id += 1

                        anchor_dict[anchor].add_alignment(aln_copy)

    for anchor in aln_to_remove :
        for pos in aln_to_remove[anchor] :
            logging.debug("Removing alignment of map %s on anchor %s" % (anchor_dict[anchor].alignments[pos].map_id, anchor))
        anchor_dict[anchor].alignments = [i for j, i in enumerate(anchor_dict[anchor].alignments) if j not in aln_to_remove[anchor]]


    logging.info("Sorting alignments")
    for anchor in anchor_dict :
        anchor_dict[anchor].sort_alignments()


    logging.info("Reordering maps")
    seen_maps = set()
    agp = open(args.prefix + ".agp", "w")
    fasta = open(args.prefix + ".fasta", "w")
    scaffolds_N_positions = defaultdict(list)
    for anchor_number, anchor in enumerate(sorted(anchor_dict.keys())) :
        previous_contig_maps = {}

        agp_scaffold_name = "Super-Scaffold_%s" % (anchor)
        agp_scaffold_start = 1
        agp_scaffold_end = 1
        agp_id = 1
        agp_contig_name = ""
        agp_contig_start = 1
        agp_contig_end = 1
        agp_strand = ""

        contig_map_1 = ""
        contig_map_2 = ""
        intersection = set()

        contig_1_last_shared_label_position = 0
        contig_2_last_shared_label_position = 0

        anchor_maps = anchor_dict[anchor].maps

        if anchor_number == 0 and len(anchor_maps) > 0 :
            fasta.write(">%s\n" % (agp_scaffold_name))
        elif len(anchor_maps) > 0 :
            fasta.write("\n>%s\n" % (agp_scaffold_name))

        for i in range(len(anchor_maps)) :
            if i < len(anchor_maps) - 1 :
                contig_map_1 = anchor_maps[i]
                contig_map_2 = anchor_maps[i+1]
                intersection = Alignment.find_shared_labels(anchor_dict[anchor], anchor_maps[i], anchor_maps[i+1])
            else :
                contig_map_1 = anchor_maps[i]
                contig_map_2 = anchor_maps[i-1]
                intersection = Alignment.find_shared_labels(anchor_dict[anchor], anchor_maps[i], anchor_maps[i-1])

            # Verify if a shared label comes from the same channel in the two maps
            # If not, remove it from the intersection
            for label in intersection :
                try :
                    label_1 = anchor_dict[anchor].find_label_on_contig_map(contig_map_1, label)
                    label_2 = anchor_dict[anchor].find_label_on_contig_map(contig_map_2, label)

                    label_1_channel = maps_to_contigs[contig_map_1].labels[label_1 - 1][2]
                    label_2_channel = maps_to_contigs[contig_map_2].labels[label_2 - 1][2]

                    if label_1_channel != label_2_channel :
                        intersection.remove(label)
                        logging.debug("Label %s on map %s is not from the same channel as label %s on map %s (%s vs %s)" % (label_1, contig_map_1, label_2, contig_map_2, label_1_channel, label_2_channel))
                except :
                    logging.debug("MAP 1 : Searched label %s on map %s (%s labels)" % (label_1, contig_map_1, len(maps_to_contigs[contig_map_1].labels)))
                    logging.debug("MAP 2 : Searched label %s on map %s (%s labels)" % (label_2, contig_map_2, len(maps_to_contigs[contig_map_2].labels)))

            contig_map_1_mapping_pos = anchor_dict[anchor].get_alignment_positions(contig_map_1)
            contig_map_2_mapping_pos = anchor_dict[anchor].get_alignment_positions(contig_map_2)

            # If the two maps are not overlapping, they can't share labels
            if Alignment.get_overlap_size(contig_map_1_mapping_pos, contig_map_2_mapping_pos) == 0 and intersection :
                intersection = set()
                logging.debug("Removed intersection from maps %s and %s on anchor %s" % (contig_map_1, contig_map_2, anchor))

            # The contig map shares labels with an other map
            if intersection :
                contig_map_1_last_shared_label = anchor_dict[anchor].find_label_on_contig_map(contig_map_1, intersection[-1])
                contig_map_2_last_shared_label = anchor_dict[anchor].find_label_on_contig_map(contig_map_2, intersection[-1])

                # Get the position of the last shared label on contig maps
                # Multiple cases that depend of the alignment orientation
                # Also verify that the label position is not out of map2 alignment position
                # This would indicate a wrong label channel
                # In case of wrong channel, we can't decide which position to pick so we empty intersection
                if contig_map_1_mapping_pos[2] == "+" and contig_map_2_mapping_pos[2] == "+":
                    contig_1_last_shared_label_position = max(maps_to_contigs[contig_map_1].get_label_position_on_contig(contig_map_1_last_shared_label, contig_map_1_mapping_pos[4]))
                    contig_2_last_shared_label_position = min(maps_to_contigs[contig_map_2].get_label_position_on_contig(contig_map_2_last_shared_label, contig_map_2_mapping_pos[4]))

                    try :
                        if contig_map_1_mapping_pos[0] + maps_to_contigs[contig_map_1].get_label_position_on_map(contig_map_1_last_shared_label) + 20000 < contig_map_2_mapping_pos[0] :
                            logging.debug("Wrong channel (%s - %s). Intersection emptied." % (contig_map_1, contig_map_2))
                            intersection = set()
                    except :
                        pass

                elif contig_map_1_mapping_pos[2] == "+" and contig_map_2_mapping_pos[2] == "-":
                    contig_1_last_shared_label_position = max(maps_to_contigs[contig_map_1].get_label_position_on_contig(contig_map_1_last_shared_label, contig_map_1_mapping_pos[4]))
                    contig_2_last_shared_label_position = max(maps_to_contigs[contig_map_2].get_label_position_on_contig(contig_map_2_last_shared_label, contig_map_2_mapping_pos[3]))

                    try :
                        if contig_map_1_mapping_pos[0] + maps_to_contigs[contig_map_1].get_label_position_on_map(contig_map_1_last_shared_label) + 20000 < contig_map_2_mapping_pos[0] :
                            logging.debug("Wrong channel (%s - %s). Intersection emptied." % (contig_map_1, contig_map_2))
                            intersection = set()
                    except :
                        pass

                elif contig_map_1_mapping_pos[2] == "-" and contig_map_2_mapping_pos[2] == "+":
                    contig_1_last_shared_label_position = min(maps_to_contigs[contig_map_1].get_label_position_on_contig(contig_map_1_last_shared_label, contig_map_1_mapping_pos[3]))
                    contig_2_last_shared_label_position = min(maps_to_contigs[contig_map_2].get_label_position_on_contig(contig_map_2_last_shared_label, contig_map_2_mapping_pos[4]))

                    try :
                        if contig_map_1_mapping_pos[1] - maps_to_contigs[contig_map_1].get_label_position_on_map(contig_map_1_last_shared_label) + 20000 < contig_map_2_mapping_pos[0] :
                            logging.debug("Wrong channel (%s - %s). Intersection emptied." % (contig_map_1, contig_map_2))
                            intersection = set()
                    except :
                        pass

                elif contig_map_1_mapping_pos[2] == "-" and contig_map_2_mapping_pos[2] == "-":
                    contig_1_last_shared_label_position = min(maps_to_contigs[contig_map_1].get_label_position_on_contig(contig_map_1_last_shared_label, contig_map_1_mapping_pos[3]))
                    contig_2_last_shared_label_position = max(maps_to_contigs[contig_map_2].get_label_position_on_contig(contig_map_2_last_shared_label, contig_map_2_mapping_pos[3]))

                    try :
                        if contig_map_1_mapping_pos[1] - maps_to_contigs[contig_map_1].get_label_position_on_map(contig_map_1_last_shared_label) + 20000 < contig_map_2_mapping_pos[0] :
                            logging.debug("Wrong channel (%s - %s). Intersection emptied." % (contig_map_1, contig_map_2))
                            intersection = set()
                    except :
                        pass

                if intersection :
                    # If contig_map_1 was never seen before, that means that it has no overlap with previously examined maps and that we can set its start and end coordinates
                    if contig_map_1 not in previous_contig_maps :
                        if contig_map_1_mapping_pos[2] == "+" :
                            agp_contig_start = maps_to_contigs[contig_map_1].start
                            agp_contig_end = contig_1_last_shared_label_position
                        else :
                            agp_contig_start = contig_1_last_shared_label_position
                            agp_contig_end = maps_to_contigs[contig_map_1].end
                        previous_contig_maps[contig_map_2] = contig_2_last_shared_label_position

                    # Otherwise we need to get the label position that was shared with the previous map
                    else :
                        if contig_map_1_mapping_pos[2] == "+" :
                            if i < len(anchor_maps) -1 :
                                agp_contig_start = previous_contig_maps[contig_map_1]
                                agp_contig_end = contig_1_last_shared_label_position
                            else :
                                agp_contig_start = previous_contig_maps[contig_map_1]
                                agp_contig_end = maps_to_contigs[contig_map_1].end                       
                        else :
                            if i < len(anchor_maps) - 1 :
                                agp_contig_start = contig_1_last_shared_label_position
                                agp_contig_end = previous_contig_maps[contig_map_1]
                            else :
                                agp_contig_start = maps_to_contigs[contig_map_1].start
                                agp_contig_end = previous_contig_maps[contig_map_1]
                        previous_contig_maps[contig_map_2] = contig_2_last_shared_label_position

                    if not previous_contig_maps[contig_map_2] :
                        if contig_map_2_mapping_pos[2] == "+" :
                            previous_contig_maps[contig_map_2] = 1
                        else :
                            previous_contig_maps[contig_map_2] = maps_to_contigs[contig_map_1].end

                    # if contig_map_1 == 85 :
                    #     print(contig_map_1)
                    #     print(contig_map_1_mapping_pos)
                    #     print(contig_map_2)
                    #     print(contig_map_2_mapping_pos)
                    #     print(intersection)
                    #     print(contig_map_1_last_shared_label)
                    #     print(contig_1_last_shared_label_position)
                    #     exit()
                    
                    agp_scaffold_end = agp_scaffold_start + agp_contig_end - agp_contig_start

                    agp.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (agp_scaffold_name,
                        agp_scaffold_start,
                        agp_scaffold_end,
                        agp_id,
                        "W",
                        maps_to_contigs[contig_map_1].base_contig_name,
                        agp_contig_start + 1,
                        agp_contig_end,
                        contig_map_1_mapping_pos[2]))

                    contig_name = maps_to_contigs[contig_map_1].base_contig_name
                    seq = Seq(dict_sequences[contig_name][agp_contig_start:agp_contig_end])

                    if contig_map_1_mapping_pos[2] == "+" :
                        fasta.write("%s" % (seq))
                    else :
                        fasta.write("%s" % (seq.reverse_complement()))

                    agp_id += 1

            # The map doesn't share any label with the next one
            if not intersection :
                if contig_map_1 not in previous_contig_maps :
                    agp_contig_start = maps_to_contigs[contig_map_1].start
                    agp_contig_end = maps_to_contigs[contig_map_1].end

                else :
                    if contig_map_1_mapping_pos[2] == "+" :
                        agp_contig_start = previous_contig_maps[contig_map_1]
                        agp_contig_end = maps_to_contigs[contig_map_1].end
                    else :
                        agp_contig_start = maps_to_contigs[contig_map_1].start
                        agp_contig_end = previous_contig_maps[contig_map_1]
      
                agp_scaffold_end = agp_scaffold_start + agp_contig_end - agp_contig_start

                agp.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" % (agp_scaffold_name,
                    agp_scaffold_start,
                    agp_scaffold_end,
                    agp_id,
                    "W",
                    maps_to_contigs[contig_map_1].base_contig_name,
                    agp_contig_start + 1,
                    agp_contig_end,
                    contig_map_1_mapping_pos[2]))

                contig_name = maps_to_contigs[contig_map_1].base_contig_name
                seq = Seq(dict_sequences[contig_name][agp_contig_start:agp_contig_end])

                if contig_map_1_mapping_pos[2] == "+" :
                    fasta.write("%s" % (seq))
                else :
                    fasta.write("%s" % (seq.reverse_complement()))

                agp_id += 1

                if i < len(anchor_maps) - 1 : 
                    space_between_contig_maps_labels = contig_map_2_mapping_pos[0] - contig_map_1_mapping_pos[1]
                    
                    if contig_map_1_mapping_pos[2] == "+" and contig_map_2_mapping_pos[2] == "+" :
                        contig_map_1_length_delta = maps_to_contigs[contig_map_1].size - contig_map_1_mapping_pos[4]
                        contig_map_2_length_delta = contig_map_2_mapping_pos[3]

                    elif contig_map_1_mapping_pos[2] == "+" and contig_map_2_mapping_pos[2] == "-" :
                        contig_map_1_length_delta = maps_to_contigs[contig_map_1].size - contig_map_1_mapping_pos[4]
                        contig_map_2_length_delta = maps_to_contigs[contig_map_2].size - contig_map_2_mapping_pos[3]

                    elif contig_map_1_mapping_pos[2] == "-" and contig_map_2_mapping_pos[2] == "+" :
                        contig_map_1_length_delta = contig_map_1_mapping_pos[4]
                        contig_map_2_length_delta = contig_map_2_mapping_pos[3]

                    elif contig_map_1_mapping_pos[2] == "-" and contig_map_2_mapping_pos[2] == "-" :
                        contig_map_1_length_delta = contig_map_1_mapping_pos[4]
                        contig_map_2_length_delta = maps_to_contigs[contig_map_2].size - contig_map_2_mapping_pos[3]

                    number_of_N_to_add = space_between_contig_maps_labels - contig_map_1_length_delta - contig_map_2_length_delta


                    if number_of_N_to_add < 0 :
                        number_of_N_to_add = 13

                    agp_scaffold_start = agp_scaffold_end + 1

                    agp_scaffold_end = agp_scaffold_start + number_of_N_to_add - 1
                    agp.write("%s\t%s\t%s\t%s\t%s\t%s\tscaffold\tyes\tmap\n" % (agp_scaffold_name,
                        agp_scaffold_start,
                        agp_scaffold_end,
                        agp_id,
                        "N",
                        number_of_N_to_add))

                    fasta.write("N" * number_of_N_to_add)

                    # If the number of Ns is small, verify if the two zones are overlapping by aligning them during phase 2
                    if number_of_N_to_add <= 100 :
                        scaffolds_N_positions[agp_scaffold_name].append((agp_scaffold_start, agp_scaffold_end))

                    agp_id += 1

            agp_scaffold_start = agp_scaffold_end + 1
            seen_maps.add(contig_map_1)


    logging.info("Adding non-scaffolded contigs")
    for m in maps_to_contigs :
            if m not in seen_maps :
                base_contig_name = maps_to_contigs[m].base_contig_name
                contig_name = maps_to_contigs[m].contig_name
                start = maps_to_contigs[m].start
                end = maps_to_contigs[m].end
                agp.write("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n"  % (contig_name,
                        1,
                        end - start,
                        1,
                        "W",
                        base_contig_name,
                        start + 1,
                        end,
                        "+"))
                fasta.write("\n>%s\n%s\n" % (contig_name, dict_sequences[base_contig_name][start:end]))
    agp.close()
    fasta.close()

    logging.info("Phase 1 ended successfully")
    logging.info("Starting phase 2")
    os.chdir("..")
    try :
        os.mkdir("Phase_2")
    except :
        logging.debug("Phase_2 directory already created")
    os.chdir("Phase_2")


    logging.info("Loading scaffolds")
    with open("../Phase_1/" + args.prefix + ".fasta") as scaffolds :
            for record in SeqIO.parse(scaffolds, "fasta") :
                    dict_sequences[record.description] = str(record.seq)


    logging.info("Starting alignments")
    changes_file = open("changes.txt", "w")
    for scaffold_name in scaffolds_N_positions :
        for start, end in scaffolds_N_positions[scaffold_name] :
            with open("seq_1.tmp", "w") as seq_1 :
                seq_1.write(">%s_%s\n%s" % (scaffold_name, start, dict_sequences[scaffold_name][max(0, start - 30000): start]))
            with open("seq_2.tmp", "w") as seq_2 :
                seq_2.write(">%s_%s\n%s" % (scaffold_name, end, dict_sequences[scaffold_name][end : end + 30000]))

            Misc.launch_blat()
            ref_size, aln_ref_end, aln_query_end = Alignment.parse_blat(scaffold_name, start)

            if aln_ref_end :
                changes_file.write("%s\t%s\t%s\t%s\t%s\n" % (scaffold_name, start, aln_ref_end, aln_query_end, ref_size))
    changes_file.close()


    logging.info("Generating new AGP file")
    Misc.mute_agp_file("../Phase_1/%s.agp" % (args.prefix), "changes.txt", args.prefix)
    os.remove("blat_output.tmp")
    os.remove("seq_1.tmp")
    os.remove("seq_2.tmp")
    shutil.move(args.prefix + ".agp", os.path.join(os.path.abspath(".."), args.prefix + ".agp"))

    logging.info("Generating final scaffolds file")
    os.chdir("..")
    with open(args.prefix + ".agp") as agp :
        out = open("out.tmp", "w")
        last_scaffold_name = ""
        for line in agp :
            line = line.strip().split("\t")

            scaffold_name = line[0]
            seq_type = line[4]

            if seq_type == "W" :
                contig_name = line[5]
                contig_start = int(line[6]) - 1
                contig_end = int(line[7])
                strand = line[8]

                if scaffold_name != last_scaffold_name :
                    out.write("\n>%s\n" % (scaffold_name))

                if strand == "+" :
                    out.write(dict_sequences[contig_name][contig_start : contig_end])
                else :
                    out.write(str(Seq(dict_sequences[contig_name][contig_start : contig_end]).reverse_complement()))

                last_scaffold_name = scaffold_name

            else :
                N_stretch_size = int(line[5])
                out.write("N" * N_stretch_size)
        out.close()

    with open(args.prefix + ".fasta", "w") as out :
        for record in SeqIO.parse(open("out.tmp"), "fasta") :
            out.write(record.format("fasta"))

    os.remove("out.tmp")


if __name__ == "__main__" :
    main()
